# bean究竟解决了什么问题  

最近开始深入的学习 java ,其实我在了解 java 之前一直对 bean 这个概念一直非常疑惑:明明可以用 new 的方式创建一个类且可以利用多态分别通过不同的构造方法来初始化构造不同的类配合工厂模式来满足需求，为什么要用 bean 来解决这个问题，而且为什么要用 bean 这个名字。

直到我看到了[码农翻身](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513115&idx=1&sn=da30cf3d3f163d478748fcdf721b6414#rd)的文章之后,才明白 bean 解决了什么问题和痛点。

bean 最初其实是为了桌面端开发而诞生的，类似于前端开发的 widget 组件，为了在 swing 开发中可以更好的分享自己开发的组件，方便系统修改状态及方便后续的维护，最初的 java 规定，所有的 bean 是一种符合以下规范的类:1.所有的属性必须为 private 不可以直接进行修改 2.对属性的修改获取必须用 getter setter 方法进行。 这样设计的目的其实很简单:为了代码的可维护性，不会因为后期的迭代修改导致组件无法使用。但是这样也导致了一个很麻烦的问题:很多bean文件在创建的时候需要生成很多你根本不会用到的getter setter方法，对开发者造成了很大的心智负担。随着 swing 及 java 桌面软件开发的边缘化，这种旧的 bean 定义也被人抛弃了。

随着web开发的盛行及 spring 框架的诞生，spring把注解这个功能玩出了花,利用注解可以很好的在编译的时候预执行很多初始化功能。其中之一就是带来了新的 bean 机制，利用 Bean() 这个注解，可以申明某个类为 bean 这样 spring 便会将这个类初始化并保存在一个 hashMap 中，利用这个 hashMasp  便可以实现一个全局单例工厂(还有原型模式 当然 这个另外讨论)，利用这个全局单例工厂，使用 spring 的开发者不需要在考虑类的初始化消耗和生命周期的问题，bean 对类进行了接管，保证类的引用以及存活，在需要这个类的时候只需要通过特定的工厂方法就可以获取，解决了很多头疼的问题。同时,使用注入的机制可以很好的给类初始化一个 bean 变量 ,省去了当你需要类的时候 new 的开销。